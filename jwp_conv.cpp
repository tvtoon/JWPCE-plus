//===================================================================//
//                                                                   //
//  JWPce Copyright (C) Glenn Rosenthal, 1998-2004, 2005             //
//                                                                   //
//  JWPce is free sotware distributed under the terms of the         //
//  GNU General Public License.                                      //
//                                                                   //
//===================================================================//

//===================================================================//
//
//  How the kana->kanji conversion works.  The system is stored in two
//  files.  The first file is a index file used to find the correct set
//  of conversions quickly (wnn.idx).  The second part is the actuall
//  conversion file (wnn.dct).
//
//  Note in working with the dicitonary files, all kana, kanji, and 
//  derived values have the upper bit (0x80) set on each unsigned char.  This
//  does int interfere with the values, and allows text prosesing of 
//  the rest of the string without any difficulty.
//
//  The index file:
//
//  The index file is an array of kanji_index structures.  These 
//  structres relate a key value with an offset into the dictionary 
//  file.  The key is generated by combining the lower unsigned chars of the 
//  kana into a string.  Keys stored in the index file have only three
//  kana in them.  But they only specifiy approximate locations into 
//  the actual dictionary file.
//
//  The dictionary file:
//
//  The dictionary file is arranged in lines.  Each line ends with a 
//  carage return, and contains three entries as follows:
//
//      <key><ending><kana><NL>
//
//  The key is a sequence of kana complressed into key form (see the 
//  index file).  The kana entry is actually a listing of kanji/kana
//  for the entry.  Seperate entries are separated by / characters in
//  8-bit ascii.  The ending entry determins what type of ending the 
//  kanji should go with.  An ending code of *, implies that ending 
//  kana cannot be attached to the conversion.  Verbes, and some other
//  conjigated form will allow an ending.  In most cases, the ending,
//  specifies the type of characters that can be attached to the 
//  kanji string.  For example, and ending code of s will accespt,
//  sa, shi, se, su, so, etc.  An ending of 1 indicates an ichi-dan 
//  doushi.
//
//  The list:
//
//  The list is a list of kanji compounds that can replace the kana.
//  The list is separated with '/' characters (historical reasons).
//  The last entry is the list is always the original kana string.
//  The length of the list is stored in list_len, and the list is 
//  terminated by a NULL character.  
//
//  Several pointers into the list are maintained: first, which
//  specifies the first visible kanji (the scroll contol), and 
//  selected which is the currently selected translation kanji.  
//  All of these pointers are a pointer to the first kanji in a 
//  kanji compound.
//
//  The user selection dictionary:
//
//  This dictionary stores the last kanji conversions that users 
//  have choses.  Thus is you enter Denki and chose electricity, 
//  JWPce will suggest that conversion again next time.  In the 
//  original JWP this dictionary is stored in a very different 
//  format that it is stored here.  (Original JWP file name is
//  cnvcache.sav, JWPce uses the file name user.sel.)
//
//  Several optimizations are applied to the user conversion 
//  dicitionary.  In particular, entries that result in a selection
//  of zero (first entry) are droped from the list, since this is 
//  the default.  Users where the key is more than SIZE_SELKEY (6)
//  kana in length are also dropped.  Generaly, these result in 
//  only one enry and the need for the conversion table is mimumal.
//  This optimization allows fixed length keys to be used in the 
//  table.
//
//  Dictionary organization is a key followed by an index into the 
//  the list.  Keys are fixed length, and generally do not have a 
//  trailing zero.  Keys are compared to the full depth, thus the 
//  key values are padded with zeros out the the fixed width.
//
//  System corects for changes in the user dictionary, by droping 
//  the cached selectedions that do not result in a valid kana->
//  kanji conversion.  This test is based on is the character in 
//  the list before the indicated point a '/', or the beginning of
//  the list.
//  
//  Note:
//
//  Much of the display and book-keeping that used to be done here has
//  been shifted to the class KANJI_list.  This maintains the list window,
//  scroll bar, and most of the other ascpects of the visible display.
//  this is so that this code can be used for the radical lookup also.
//
#include <algorithm>
#include <iostream>

#include "jwpce.h"
#include "jwp_conf.h"
#include "jwp_conv.h"
#include "jwp_edit.h"
#include "jwp_file.h"
#include "jwp_font.h"
#include "jwp_help.h"
#include "jwp_inpt.h"
#include "jwp_klst.h"
#include "jwp_misc.h"
#include "jwp_stat.h"

//using namespace std;

//===================================================================
//
//  Special compile time option.
//
//  CONVERT_ACCESS -- Indicates how JWPce should access the WNN 
//                    kana->kanji dictionary.  See the jwp_otpions.h
//                    file for more details.  
//
#ifndef CONVERT_ACCESS      // Make sure this is defined as something.
  #pragma message("ERROR: 'CONVERT_ACCESS' is not defined")
  #if (==0)     // Make an error 
  #endif
#endif

//===================================================================
//
//  Compile time options.
//

#define SEPARATE_SLASH  // Uses slahes to separate kanji in the kana->kanji
                        // conversion dialog boxes.  If this is not defined
                        // spaces will be used.  If you change this value 
                        // make sure to change the text in the edit conversion
                        // dialog box.

//===================================================================
//
//  Defines and types.
//
                                            // Standard file names.
#define NAME_INDEX      TEXT("wnn.dix")     // Main kana->kanji dictionary index file.
#define NAME_CONVT      TEXT("wnn.dat")     // Main kana->kanji dictionary data file.
#define NAME_USERSEL    TEXT("user.sel")    // User conversion dictionary.
#define NAME_USERCONV   TEXT("user.cnv")    // User kana-kanji conversion dictionary.

//===================================================================
//
//  Static data..
//

static SIZE_window cvrt_size;       // class for dynamic sizing of the user conversions dialog.

//===================================================================
//
//  Static processing rotuines.
//

static int cmp_key      ( const char *p1, const char *p2,int endkana);    // Compare two keys, used in the binary search.
static int test_endings (int dict,int key,int kana);        // Test endings for kana->kanji conversions.
static int test_nkey    ( const char *kana, const char *key);             // Tests is key is beginning of kana string.

//--------------------------------
//
//  Compares two keys to determine if one is bigger or smaller.
//
//      p1     -- dictionary key (has TAB) as the end marker.
//      p2     -- User key (has NULL) as end marker.
//
//      RETURN -- >0  -> p1 is latter than p2 (p1 > p2).
//                =0  -> p1 = p2
//                <0  -> p1 is before p2 (p1 < p2)
//
static int cmp_key ( const char *p1, const char *p2,int endkana) {
  for (; *p1 == *p2; p1++, p2++);
  if (( (unsigned char)*p1 <= 0x7f) && !*p2 && (endkana || (unsigned char)(*p1 == '*'))) return (0);
  return (((int) *p1) - ((int) *p2));
}

//--------------------------------
//
//  Tests the ending kana for a match.  The kana->kanji conversion
//  dictionary contains an ending code.  A code of '*' indicates no
//  special ending.  A character code indicates the ending of the 
//  verb (for godan doushi).  Codes such as n, b, g, etc. indicate
//  this is a godan doushi, and that approriate endings should be 
//  used.  The WNN dictionary also contain entries like e, i, etc.
//  This is because the WNN table containes all edings, for example,
//  a verb ending in ku whould have entires for i and k, a verb ending
//  in u, would have entires for u, e, i, o, and w, etc.  The user
//  dictionary contains only the verb endings and this routien generates
//  all other endings on the fly.
//
//      dict   -- Ending listed in the dictionary.
//      key    -- Ending from key (user ending as a letter).
//      kana   -- Unser ending as kana (contains more information than
//                the letter, and allows better processing of some 
//                some entries (accepting chisai tsu instead of all 
//                t entries).
//
//      RETURN -- True value indicate the chraters match.  A False 
//                indicates no match.
//
//  Because I call this routine for both the user dictionary and the 
//  WNN dictionary, dublipcate entries can be generated by the WNN
//  dictionary, because this dictionary contains entries for all 
//  possible verb endings.
//
#define BYTEKANA_TSU    (0x43)   // Key value for chisai tsu.
#define BYTEKANA_N      (0x73)   // Key value for n
#define BYTEKANA_WA     (0x6F)   // Key value for wa

static int test_endings (int dict,int key,int kana) {
  if (dict == '1') return (true);           // This is an ichi-dan verb ending so all endings match.
  if (dict == 'i') return (true);           // This is an i-keiyoushi, so all endings will be accepted.
  if (dict == key) return (true);           // Same character is always a match.
  switch (dict) {                           // All other codes have different choices.
    case 'u':   // e,i,o,tsu,wa
         if ((key == 'e') || (key == 'o') || ((kana & 0x7f) == BYTEKANA_WA) || ((kana & 0x7f) == BYTEKANA_TSU)) return (true);
    case 'k':   // **** FALL THROUGH **** 
    case 'g':   // i
         if (key == 'i') return (true);
         break;
    case 'r': 
    case 'd':   // tsu
          if ((kana & 0x7f) == BYTEKANA_TSU) return (true);
          break;
    case 'f': 
    case 'b': 
    case 'p': 
    case 'm':   // n
         if ((kana & 0x7f) == BYTEKANA_N) return (true);
         break;
//  case 'n':                               // These no special cases.
//  case 's': 
//  case 'z':   // Verbs ending with zu ?
//  case 't':
    default:
         break;   
  }
  return (false);
}

//--------------------------------
//
//  Compares two keys, requiring that key and kana be identical to the
//  end of key.
//
//      kana   -- Kana key to be compared against.  Generally it is thought
//                that this should be longer than key.
//      key    -- Key to be tested.
//
//      RETURN -- A nonzer value indicates that key and kana are identical
//                to at least the end of key.  This is used to see if 
//                there are kanji compounds that can be made by adding 
//                more kana to key.
//
static int test_nkey ( const char *kana, const char *key) {
  while (*key && (*kana == *key)) { kana++; key++; }
  return (!*key);
}

//===================================================================
//
//  Window proc for handling the conversion bar.
//
static LRESULT CALLBACK JWP_conv_proc (HWND hwnd,unsigned int iMsg,WPARAM wParam,LPARAM lParam);

//--------------------------------
//
//  Window proc for the conversion bar.
//
static LRESULT CALLBACK JWP_conv_proc (HWND hwnd,unsigned int iMsg,WPARAM wParam,LPARAM lParam) {
  HDC         hdc;
  PAINTSTRUCT ps;
  switch (iMsg) {
    case WM_CREATE:
         jwp_conv.adjust (hwnd);
         return (0);
    case WM_PAINT:
         hdc = BeginPaint (hwnd,&ps);
         SetTextColor  (hdc,GetSysColor(COLOR_WINDOWTEXT));
         SetBkColor    (hdc,GetSysColor(COLOR_BTNFACE));
         jwp_conv.draw (hdc);
         EndPaint      (hwnd,&ps);
         return (0);
    case WM_HSCROLL:
         jwp_conv.do_scroll(wParam);
         return (0);
#ifndef WINCE
    case WM_MOUSEWHEEL:
         jwp_conv.do_wheel(wParam);
         return (0);
#endif
    case WM_LBUTTONDOWN:                        // Left button.
         if (GetKeyState(VK_MENU) >= 0) {       // Alt+left bufgton makes a right button
           jwp_conv.do_mouse (lParam);          // Simply changes the selection.
           return (0);
         }
    case WM_RBUTTONDOWN:                        // Right button
         if (lParam != -1) jwp_conv.do_mouse (lParam);  // Set mouse position
         jwp_conv.get_info (GetFocus());
         return (0);
  }
  return (DefWindowProc(hwnd,iMsg,wParam,lParam));
}

//===================================================================
//
//  Begin Class EDIT_userconv.
//
//  This class and it's support routines allow editing of the user 
//  conversion dictionary.  This class is based in the EDIT_list 
//  class defined in the modlue jwp_edit.
//

//-------------------------------------------------------------------
//
//  Class defintion.
//

class EDIT_userconv : public EDIT_list {
public:
//  int   dlg_convert (HWND hwnd,unsigned int message,WPARAM wParam,LPARAM lParam);
  int   dlg_convert (HWND hwnd,unsigned int message,WPARAM wParam );
  char *get_data    (void);                     // Get data from the list into working format.
  void  put_data    (unsigned char *data,tchar *name);   // Put data into the dialog box for initialize.
private:
  int   check_error (int data, const char *name);     // Check for import error.
  int   edit        (void);                     // Edit/Add entry procedure.
};

//-------------------------------------------------------------------
//
//  Godan utility routines.
//

#define NUMBER_GODANS ((int) (sizeof(godans)/sizeof(struct godan)))

static int godan_ascii (KANJI kanaji);          // Get ascii character assocated with a godan verb.

struct godan {      // Structure relating ascii values for the godan doushi and their hiragana values.
  unsigned char kana;        // kana value (just low unsigned char).
  unsigned char ascii;       // Ascii value of first character.
};

static struct godan godans[] = { 
  { 0x26,'u' },{ 0x2F,'k' },{ 0x30,'g' },{ 0x39,'s' },{ 0xC4,'t' },
  { 0x4C,'n' },{ 0x56,'b' },{ 0x60,'m' },{ 0x6B,'r' }
};

//--------------------------------
//
//  Gets the ascii character assoicated with a godan verb ending.  For
//  example, if you pass it the character ku, you will get the character
//  k as the return.
//
//      kanji  -- Character to look for (the kana).
//
//      RETURN -- The return value is the ascii character at the beginning
//                of the godan, or NULL, indicating you have passed 
//                an invalid godan character.
//
static int godan_ascii (KANJI kana) {
  int i;
  for (i = 0; i < NUMBER_GODANS; i++) {
    if (godans[i].kana == (kana & 0xff)) return (godans[i].ascii);
  }
  return (0);
}

//--------------------------------
//
//  From an ascii character, get the kana character that is the end 
//  of the godan character.
//
//      ascii  -- Ascii character to look for (You must pass u for a, i, e, o).
//
//      RETURN -- The kana for the end of the godan verb, or a NULL if 
//                this is not a valid godan character.
//
int godan_kana (int ascii) {
  int i;
  for (i = 0; i < NUMBER_GODANS; i++) {
    if (ascii == godans[i].ascii) return (godans[i].kana | BASE_HIRAGANA);
  }
  return (0);
}

//-------------------------------------------------------------------
//
//  Static data and routines.
//

#ifdef SEPARATE_SLASH
#define KANJI_SEPARATOR KANJI_SLASH
  #define ISSEPARATOR(x) ((x == KANJI_SLASH) || (x == '/'))
#else
  #define KANJI_SEPARATOR KANJI_SPACE;
  #define ISSEPARATOR(x) (ISSPACE(x))
#endif

// Pointer to class instance so dialog procedure can find us.
EDIT_userconv *edit_userconv = NULL;

//--------------------------------
//
//  Stub dialog box routine.
//
// LPARAM lParam - useless
static int dialog_convert (HWND hwnd,unsigned int message,WPARAM wParam ) {
  return (edit_userconv->dlg_convert(hwnd,message,wParam ));
}

//-------------------------------------------------------------------
//
//  Class routines.
//

//--------------------------------
//
//  Internal error check and display routine.  This is used by the 
//  put_data fucntion to check the validility of the data being added 
//  to the list.  The checks performed include makeing sure the 
//  length of the kbuffer is not too long, and that the current poitner
//  is not past the end of the buffer.
//
//      data   -- Current data element.  If this is zero, we are past 
//                the end of the data buffer and have an error.  This 
//                can be passed in as zero to force an error.
//      name   -- Name of data file for error message.
//
//      RETURN -- A non-zero value indicates an error and should abort
//                the import operation.
//
int EDIT_userconv::check_error (int data, const char *name) {
  if ((length < SIZE_BUFFER-6) && data) return (false);
  if (!name) name = jwp_config.name(NAME_USERCONV,OPEN_WRITE,true);
  JMessageBox (dialog,IDS_CE_ERRORTEXT,IDS_CE_ERRORTITLE,MB_OK | MB_ICONERROR,name);
  return (true);
}

//--------------------------------
//
//  Required virtual function to edit an entry.  This just invokes the 
//  edit dialog box.  All of the real work is there.
//
int EDIT_userconv::edit () {
  return (JDialogBox(IDD_CONVERTEDIT,dialog,(DLGPROC) dialog_convert));
}

//--------------------------------
//
//  This is the dialog procedure to edit an entry for the user conversion
//  dictionary.
//
//      IDC_CEKANA       Kana string
//      IDC_CEKANJI      Kanji string.
//      IDC_CEGODAN      Godan-doushi checkbox.
//
// LPARAM lParam - useless
int EDIT_userconv::dlg_convert (HWND hwnd,unsigned int message,WPARAM wParam ) {
  KANJI *kkana,*kkanji;
  int    lkana, lkanji;
  int i;
  switch (message) {
//
//  Initialize the dialog box.  Read the data from the kbuffer, and 
//  setup the dialog parameters.
//
    case WM_INITDIALOG:
         if (length) {
           for (i = 0; kbuffer[i] != KANJI_SPACE; i++);
           SendDlgItemMessage (hwnd,IDC_CEKANJI,JE_SETTEXT,length-i-3,(LPARAM) (kbuffer+i+3));           
           if (kbuffer[i-1] == ']') {
             CheckDlgButton (hwnd,IDC_CEGODAN,true);
             kbuffer[i-3] = kbuffer[i-2];
             i -= 2;
           }
           else if (kbuffer[i-1] == '}') {
             CheckDlgButton (hwnd,IDC_CEIADJ,true);
             kbuffer[i-3] = kbuffer[i-2];
             i -= 2;
           }
           else if (kbuffer[i-1] == ')') {
             CheckDlgButton (hwnd,IDC_CEICHIDAN,true);
             kbuffer[i-3] = kbuffer[i-2];
             i -= 2;
           }
           SendDlgItemMessage (hwnd,IDC_CEKANA ,JE_SETTEXT,i,(LPARAM) kbuffer);
         }
         return (true);
//
//  Process Help
//
    case WM_HELP:
         do_help (hwnd,IDH_TEXT_USERKANJI);
         return  (true);
    case WM_COMMAND:
         switch (LOWORD(wParam)) {
           case IDC_CEGODAN:
                if (IsDlgButtonChecked(hwnd,IDC_CEGODAN)) {
                  CheckDlgButton (hwnd,IDC_CEICHIDAN,false);
                  CheckDlgButton (hwnd,IDC_CEIADJ   ,false);
                }
                return (true);
           case IDC_CEICHIDAN:
                if (IsDlgButtonChecked(hwnd,IDC_CEICHIDAN)) {
                  CheckDlgButton (hwnd,IDC_CEGODAN,false);
                  CheckDlgButton (hwnd,IDC_CEIADJ ,false);
                }
                return (true);
           case IDC_CEIADJ:
                if (IsDlgButtonChecked(hwnd,IDC_CEIADJ)) {
                  CheckDlgButton (hwnd,IDC_CEICHIDAN,false);
                  CheckDlgButton (hwnd,IDC_CEGODAN  ,false);
                }
                return (true);
//
//  User wants to keep this conversion, so see what is up.
//
           case IDOK:
           case IDSEARCH:
//
//  Get strings and make sure they are not empty.
//
                lkana  = JEGetDlgItemText(hwnd,IDC_CEKANA ,&kkana );
                lkanji = JEGetDlgItemText(hwnd,IDC_CEKANJI,&kkanji);
                if (!lkana || !lkanji) {
                  JMessageBox (hwnd,IDS_CE_ERROREMPTY,IDS_CE_ERRORTITLE,MB_OK | MB_ICONWARNING);
                  SetFocus    (GetDlgItem(hwnd,lkana ? IDC_CEKANJI : IDC_CEKANA));
                  return (true);
                }
//
//  Build buffer string.
//
                length = 0;
                for (i = 0; i < lkana; i++) {               // Process kana
                  if (!ISHIRAGANA(kkana[i])) {              // Kana should be hiragana.
                    JMessageBox (hwnd,IDS_CE_ERRORKANA,IDS_CE_ERRORTITLE,MB_OK | MB_ICONWARNING);
                    SetFocus   (GetDlgItem(hwnd,IDC_CEKANA));
                    return (true);
                  }
                  kbuffer[length++] = kkana[i];
                }
//
//  Process godan doushi.
//
                if (IsDlgButtonChecked(hwnd,IDC_CEGODAN)) {
                  if (kkana[lkana-1] == kkanji[lkanji-1]) lkanji--;
                  if (!godan_ascii(kkana[lkana-1])) {
                    JMessageBox (hwnd,IDS_CE_ERRORGODAN,IDS_CE_ERRORTITLE,MB_OK | MB_ICONWARNING);
                    SetFocus    (GetDlgItem(hwnd,IDC_CEKANA));
                    return      (true);
                  }
                  kbuffer[length] = kbuffer[length - 1];    // Build bracked ending.
                  length++;
                  kbuffer[length-2] = '[';
                  kbuffer[length] = ']';
                  length++;
                  for (i = 0; i < lkanji; i++) {            // Check kanji.
                    if (ISSEPARATOR(kkanji[i])) {           // Multi-listing is an error.
                      JMessageBox (hwnd,IDS_CE_ERRORVERB,IDS_CE_ERRORTITLE,MB_OK | MB_ICONWARNING);
                      SetFocus    (GetDlgItem(hwnd,IDC_CEKANJI));
                      return      (true);
                    }
                  }
                }
//
//  Process ichidan doushi.
//
#define KANA_RU 0x246b
                if (IsDlgButtonChecked(hwnd,IDC_CEICHIDAN)) {
                  if (kkana[lkana-1] == kkanji[lkanji-1]) lkanji--;
                  if (kkana[lkana-1] == KANA_RU) length--;
                    else {
                      JMessageBox (hwnd,IDS_CE_ERRORRUVERB,IDS_CE_ERRORTITLE,MB_OK | MB_ICONWARNING);
                      SetFocus    (GetDlgItem(hwnd,IDC_CEKANA));
                      return      (true);
                    }
                  for (i = 0; i < lkanji; i++) {            // Check kanji.
                    if (ISSEPARATOR(kkanji[i])) {           // Multi-listing is an error.
                      JMessageBox (hwnd,IDS_CE_ERRORVERB,IDS_CE_ERRORTITLE,MB_OK | MB_ICONWARNING);
                      SetFocus    (GetDlgItem(hwnd,IDC_CEKANJI));
                      return      (true);
                    }
                  }
                  kbuffer[length++] = '(';
                  kbuffer[length++] = KANA_RU;              // Build bracked ending.
                  kbuffer[length++] = ')';
                }
//
//  Process i-keiyoushi doushi.
//
#define KANA_I  0x2424
                if (IsDlgButtonChecked(hwnd,IDC_CEIADJ)) {
                  if (kkana[lkana-1] == kkanji[lkanji-1]) lkanji--;
                  if (kkana[lkana-1] == KANA_I) length--;
                    else {
                      JMessageBox (hwnd,IDS_CE_ERRORIADJ,IDS_CE_ERRORTITLE,MB_OK | MB_ICONWARNING);
                      SetFocus    (GetDlgItem(hwnd,IDC_CEKANA));
                      return      (true);
                    }
                  for (i = 0; i < lkanji; i++) {            // Check kanji.
                    if (ISSEPARATOR(kkanji[i])) {           // Multi-listing is an error.
                      JMessageBox (hwnd,IDS_CE_ERRORVERB,IDS_CE_ERRORTITLE,MB_OK | MB_ICONWARNING);
                      SetFocus    (GetDlgItem(hwnd,IDC_CEKANJI));
                      return      (true);
                    }
                  }
                  kbuffer[length++] = '{';
                  kbuffer[length++] = KANA_I;               // Build bracked ending.
                  kbuffer[length++] = '}';
                }
//
//  Make arrow.
//
                kbuffer[length++] = KANJI_SPACE;
                kbuffer[length++] = KANJI_ARROW;
                kbuffer[length++] = KANJI_SPACE;
//
//  Do the kanji.
//
                for (i = 0; i < lkanji; i++) kbuffer[length++] = kkanji[i];
                EndDialog (hwnd,true);
                return (true);
           case IDCANCEL:
                EndDialog (hwnd,false);
                return (true);
         }
  }
  return (false);
}

//--------------------------------
//
//  Get data from the list-box and generate a user conversion dictionary.
//
//      RETURN -- pointer to dictionary file.
//      
char *EDIT_userconv::get_data () {
  int i,index;
  char *data,*ptr;
//
//  Allocate memory.
//                
  if (!(data = (char *) calloc(1,size()))) { OutOfMemory (dialog); return (data); }
  ptr   = data;
  index = 0;
  while (index < count()) {                     // Whey there are items keep processing.
    get_buffer (index);                         // Get buffer.
    for (i = 0; (kbuffer[i] != KANJI_SPACE) && (kbuffer[i] != '[') && (kbuffer[i] != '(') && (kbuffer[i] != '{'); i++) *ptr++ = (kbuffer[i] & 0x007f) | 0x80;
    switch (kbuffer[i]) {
      case '{':                                 // i-keiyoushi
           *ptr++ = 'i';
           i += 3;
           break;
      case '(':                                 // Ichi-dan doushi
           *ptr++ = '1';
           i += 3;
           break;
      case '[':                                 // Go-dan doushi
           *ptr++ = godan_ascii(kbuffer[i+1]);
           i += 3;
           break;
      default:                                  // All others
           *ptr++ = '*';
           break;
    }
    for (i += 3; i < length; i++) {             // Do the kanji.
      if (ISSEPARATOR(kbuffer[i])) *ptr++='/';  // Kanji separator.
        else {
          *ptr++ = (kbuffer[i] >> 8) | 0x80;
          *ptr++ = (kbuffer[i] & 0x00ff) | 0x80;
        }
    }
    *ptr++ = '\n';                              // Genarate end of line
    index  = next_item(index);                  // Move to next item.
  };
  return (data);
}

//--------------------------------
//
//  This routine takes data and loads it into the edit-list box.  This
//  routine translates the data to the form correct for the list box.
//
//      data -- Pointer to the user dictionary.
//
//  Entry format:
//
//      <kana(compressed)><TAB><letter><TAB><KANJI>{/<KANJI>}<CR><LF>
//
void EDIT_userconv::put_data (unsigned char *data,tchar *name) {
  int j;
  while (*data) {                                   // Process all data.
    length = 0;                                     // Start new line
    while (*data > 0x7f) {                          // Hiragana until first tab.
      if (check_error(*data,name)) return;          // Error!
      kbuffer[length++] = (BASE_HIRAGANA | *data++) & 0x7f7f;
    }
    if (*data == 'i') {
      kbuffer[length++] = '{';
      kbuffer[length++] = 0x2424;
      kbuffer[length++] = '}';
    }
    else if (*data == '1') {
      kbuffer[length++] = '(';
      kbuffer[length++] = 0x246b;
      kbuffer[length++] = ')';
    }
    else if (*data != '*') {                        // Not * idnicates a godan-doushi.
      if (!(j = godan_kana(*data))) { check_error(0,name); return; }  // Error!
      kbuffer[length++] = '[';
      kbuffer[length++] = j;
      kbuffer[length++] = ']';
    }
    data++;                                         // Skip char
    kbuffer[length++] = KANJI_SPACE;                // Build arrow.
    kbuffer[length++] = KANJI_ARROW;
    kbuffer[length++] = KANJI_SPACE;
    while (*data != '\n') {                         // KANJI entries
      if (check_error(*data,name)) return;          // Error!
      if (*data == '/') {                           // New kanji entry.
        kbuffer[length++] = KANJI_SEPARATOR;    
      }
      else {                                        // Just kanji.
        j = *data++;
        kbuffer[length++] = ((j << 8) | *data) & 0x7f7f;
      }
      data++;
    }
    data++;                                         // Skip <NL>
    clear     ();                                   // Put in list.
    put_kanji (kbuffer,length);
    flush     (-1);
  }
  return;
}

//-------------------------------------------------------------------
//
//  Class JWP_conv routines.
//

//--------------------------------
//
//  Compairosn routine for kana->kanji conversion entries.  This is used to sort the 
//  list of entries.
//
//      buf1,buff2 -- Pointer to strings to be compaired.
//
//      return     -- Non-zero value indicates buf2 should precede buf1.
//
static int convert_compare (KANJI *buf1,KANJI *buf2) {
  int c1,c2;
  c1 = c2 = 0;
  while (*buf1 == *buf2) {
    buf1++;
    buf2++;
    if ((*buf1 == '[') || (*buf1 == '(') || (*buf1 == '{') || (*buf1 == ']') || (*buf1 == ')') || (*buf1 == '}')) c1 = *buf1++;
    if ((*buf2 == '[') || (*buf2 == '(') || (*buf2 == '{') || (*buf2 == ']') || (*buf2 == ')') || (*buf2 == '}')) c2 = *buf2++;
    if ((*buf1 == KANJI_ARROW) && (c1 != c2)) return (c2 < c1);
  }
  for ( ; *buf1 && *buf2 && (*buf1 == *buf2); buf1++, buf2++);
  return (*buf2 < *buf1);
}

//--------------------------------
//
//  This is the dialog handler for the User Conversion Dailog box.
//  Mostly this dialog handler passes control to the EDIT_userconv
//  class which is dirived from the EDIT_list class, which manages 
//  an editable list.
//
#define RET     *((int *) lParam)

int JWP_conv::dlg_userconv (HWND hwnd,unsigned int message,WPARAM wParam,LPARAM lParam) {
  switch (message) {
    case WM_INITDIALOG:
         cvrt_size.wm_init (hwnd,IDC_EDITLIST,&jwp_config.cfg.size_cnvrt,true,0,0);
         add_dialog (dialog = hwnd,false);
         if (!(edit_userconv = new EDIT_userconv())) return (false);
         edit_userconv->init (hwnd,user,IDS_CE_FILETYPE);
         return (true);
    case WM_DESTROY:
         remove_dialog (hwnd);
//         delete edit_userconv;
         dialog = null;
         return (true);
#ifndef WINCE
    case WM_SIZING:
         cvrt_size.wm_sizing ((RECT *) lParam);
         return (0);
#endif
    case WM_SIZE:
         cvrt_size.wm_size (wParam);
         return (0);
    case WM_MOVE:
         cvrt_size.wm_move ();
         return (0);
#ifndef WINCE
    case WM_DROPFILES:                          // Drag & drop import a file
         edit_userconv->do_drop ((HDROP) wParam);
         return  (0);
#endif
    case WM_HELP:                               // Get some help for the user
         do_help (hwnd,IDH_TEXT_USERKANJI);
         return  (true);
    case WMU_OKTODESTROY:                       // The system wants to know if it is ok to destroy this window.
         if (!edit_userconv->changed) { RET = true; return (0); }
         switch (JMessageBox(hwnd,IDS_CE_CHANGEDTEXT,IDS_CE_CLOSE,MB_ICONQUESTION | MB_YESNOCANCEL)) {
           case IDNO:     RET = true;  break;
           case IDCANCEL: RET = false; break;
           case IDYES:    RET = !save_user(); break;
         }
         return (0);
    case WM_COMMAND:
         switch (LOWORD(wParam)) {              
           case IDC_UCSORT:
                edit_userconv->list->sort (convert_compare);
                return (0);
           case IDC_EDITLIST:                   // These events belong to the edit-list class.
           case IDC_EDITLISTADD:
           case IDC_EDITLISTEDIT:
           case IDC_EDITLISTUP:
           case IDC_EDITLISTDOWN:
           case IDC_EDITLISTDELETE:
           case IDC_EDITLISTIMPORT:
           case IDC_EDITLISTINSERT:
           case IDC_EDITLISTFIND:
           case IDC_EDITLISTNEXT:
                edit_userconv->do_event (wParam);
                return (0);
           case IDOK:                           // User wants to keep changes.
                if (save_user()) return (0);
           case IDCANCEL:               // **** FALL THORUGH ****
                DestroyWindow (hwnd);
                return        (0);
         }
         break;
  }
  return (0);
}

//--------------------------------
//
//  Save the user conversions databese
//
//      RETURN -- A non-zero return indicates an error.
//
int JWP_conv::save_user () {
  HANDLE file;
  unsigned int done;
  if (user) free (user);              // Remove old conversions.
  user = edit_userconv->get_data ();  // Make current conversions active oones.
  if (INVALID_HANDLE_VALUE == (file = jwp_config.open(NAME_USERCONV,OPEN_NEW,true))) {
    QUIET_ERROR {
      edit_userconv->error (IDS_CE_ERROROPEN,jwp_config.name());
      return (true);                    
    }
  }                                   // Write conversions to disk.
  WriteFile   (file,user,strlen( user),&done,NULL);
  CloseHandle (file);
  return      (false);
}

//
//  End class EDIT_userconv.
//
//===================================================================

//===================================================================
//
//  Begin Class JWP_conv.
//
//  This class handles processing of all kana->kanji converson
//  related functions.
//

#define WINCLASS_CONVERTBAR TEXT("JWP-Conv")    // Name of window class

class JWP_conv jwp_conv(500);                   // Instance of class.

//--------------------------------
//
//  Constructor.
//
JWP_conv::JWP_conv (int count) : KANJI_list (count) {
  index    = NULL; 
  user     = NULL;
  user_sel = NULL;
  dict     = null;    
  dialog   = null;
  return;
}

//--------------------------------
//
//  Destructor.
//
JWP_conv::~JWP_conv () {
#if   (CONVERT_ACCESS == CONVERT_ACCESS_MEMORY) 
  if (dict ) CloseHandle (dict);
#else
  CloseHandle (dict);
#endif
  if (index   ) free (index);
  if (user    ) free (user);
  if (user_sel) free (user_sel);
//#if 0
  user     = NULL;          // These are not actually necessary, becasue this opbject is
  dict     = NULL;          //   only created once, at the beginning and destroyed onece
  index    = NULL;          //   at the end.
  user_sel = NULL;
//#endif
  return;
}

//--------------------------------
//
//  Adjust the window, usually as a responce to a change in window 
//  size.
//
//      hwnd -- Either NULL or a window pointer.  Normally, you would
//              call this will NULL.  A value is only passed in during
//              the window creation routines.
//
extern HWND command_bar;

void JWP_conv::adjust (HWND hwnd) {
  RECT rect;
  if (!hwnd) hwnd = window;
  if (!hwnd) return; 
  height = bar_font.height+2*bar_font.vspace;
  if (jwp_config.cfg.kscroll) height += GetSystemMetrics(SM_CYHSCROLL);
#ifndef WINCE
  ShowScrollBar (hwnd,SB_HORZ,jwp_config.cfg.kscroll);
#endif
  GetClientRect (main_window,&rect);
  if (jwp_config.cfg.kanjibar_top) MoveWindow (hwnd,-1,jwp_config.commandbar_height,rect.right+2,height,true);
    else MoveWindow (hwnd,-1,rect.bottom-(height+jwp_stat.height-2),rect.right+2,height,true);
  KANJI_list::adjust (hwnd);
  return;
}

//--------------------------------
//
//  Attempt to do a conversion.  This is actually a check weather the
//  current kana string represents a valid conversion.  A number of
//  possible situations can happen:
//
//      If the current kana string has no conversion, A value of false
//      will be returned.
//
//      The current conversion is valid, and it is possible to add 
//      more characters to the string.  A value of true is returned.
//
//      If the current conversion is valid, but you cannot add additonal
//      characters to the conversion.  Kanji selection will be 
//      enabled, and a value of true will be returned.  
//
//      kanji  -- Kanji string to be tested.
//      length -- Length of the string.
//
//      RETURN -- Non-zero indicates this is a valid kana string.
//
int JWP_conv::attempt (KANJI *kana,int length) {
  int stat;
  stat = convert(kana,length);              // Attempt conversion.
  if (is_more) { clear(); return (true); }  // If can have more, clear conversion, and return true.
  if (!stat) return (false);                // Invalid conversion so return false.
  select (selected);                        // No more kana can be accepted so initiate kanji selection.
  return (true);
}

//--------------------------------
//
//  This routine finds the closes key to the supplied key within the
//  index file.  This indicates the location within actual dictionalry
//  file where one should being looking for the actual data.
//
//      key    -- Key to look for.
//
//      RETURN -- Closes matching key.
//
int JWP_conv::binary_search ( const char *key) {
  int top,bottom,middle,diff;
  top    = 0;
  bottom = size-1;
  while (true) {
    middle = (top+bottom)/2;
    diff = index_compare (key,middle);
    if (!diff) return (middle);
    if (top >= bottom-1) {
      if (!index_compare (key,bottom)) return (bottom);
      break;
    }
    if (diff > 0) top = middle; else bottom = middle;
  }
  return (top);
}

//--------------------------------
//
//  Clear the kana->kanji conversion system.
//
void JWP_conv::clear () {
  kana_convert.clear ();
  is_more  = false;
  KANJI_list::clear ();
  return;
}

//--------------------------------
//
//  Attempt to conver a kana string into kanji.  The routine makes no
//  external visible changes, but is deisgned to setup a convert that
//  can be cleared if you don't want to keep it.
//
//      kana   -- Kana string to convert.
//      length -- length of the kana string.
//
//      RETURN -- Nonzero if there are acceptable kanji.
//
int JWP_conv::convert (KANJI *kana,int length) {
 char key[SIZE_MAXKEY];
  KANJI_sel *choice;
  int i;
  clear ();                                                 // Clear any old conversion.
  if (length >= SIZE_MAXKEY) return (0);                    // Too many characters in kana list.
  for (i = 0; i < length; i++) key[i] = (( (unsigned char)kana[i] & 0x00ff) | 0x80);
  for (; i < SIZE_SELKEY; i++) key[i] = 0;
  key[i] = 0;
  if (length > SIZE_SELKEY) sel_key[0] = 0;                 // Setup sel_key for user conversion interface.
    else {
      for (i = 0; i < SIZE_SELKEY; i++) sel_key[i] = key[i];    
    }
  search (key,0);                                           // Get fixed end kanji.
  if (length > 1) {             
    key[length-1] = 0;          
    search (key,kana[length-1]);                            // Get variable end kanji
  }
  if (!list_len) return (0);                                // No kanji.
  for (i = 0; i < list_len; i++) list[i] &= 0x7f7f;         // Mask out high bits.
//
//  Add kana to the end of the .
//
  put_kanji ('/');
  for (i = 0; i < length; i++) put_kanji (kana[i]);         // Add kana string to end.
  filter ();                                                // Filter list for duplicates.
//
//  Initialize selection from the user conversion dictionary.
//                                                          // No or invalid user choice, so go with first.
  if (!(choice = find_choice()) || (choice->select > last())) selected = 0;  
    else {                                      
      selected = choice->select;                            // Get choice and check for valid.
      if (selected && (list[selected-1] != '/')) selected = 0;
    }
  return (list_len);
}

//--------------------------------
//
//  Enery point for forced conversions.
//
//      kana   -- Pointer to string of kana.
//      length -- length of pointer.
//
void JWP_conv::do_convert (KANJI *kana,int length) {
  if (!convert(kana,length)) {
    MessageBeep (MB_ICONASTERISK);
    return;
  }
  select (selected);
  redraw ();
  return;
}

//--------------------------------
//
//  Main element of the convert engine.  This routine does a conversion
//  in complete.  Note the actual display part of the conversion is 
//  not associated with this routine.
//
//      kana   -- Kana string to be converted.
//      length -- Length of the kana string.
//
//      RETURN -- A non-zero return indicates that matches were found.
//
//
//  This routine is called from the event handler for the edit window.
//  In particular, this routine is called to generate the shift right,
//  and shift left of the kanji bar.
//
//      direction -- Indicates the direction to shift:
//
//              KANJILIST_RIGHT -- Shift right.
//              KANJILIST_LEFT  -- Shift left.
//
void JWP_conv::do_select (int direction) {
  int i;
  if (direction == KANJILIST_RIGHT) {
    i = next(selected); 
    if (i == selected) i = 0;
  }
  else {
    i = prev(selected);
    if (i == selected) i = last();
  }
  select (i);
  return;
}

//--------------------------------
//
//  Called when exiting the system, this routine writes the user 
//  conversion dictionaries and the user kanji dictionary to disk.
//
void JWP_conv::done () {
  HANDLE hfile;
  DWORD  size,done;
  if (usersel_changed && user_sel) {
    size = jwp_config.cfg.convert_size*sizeof(KANJI_sel);
    if ((INVALID_HANDLE_VALUE == (hfile = jwp_config.open(NAME_USERSEL,OPEN_NEW,true))) || !WriteFile(hfile,user_sel,size,&done,NULL)) {
      QUIET_ERROR ErrorMessage (true,IDS_ERROR_SAVECONVERT,jwp_config.name());
    }
    CloseHandle  (hfile);
  }
  return;
}

//--------------------------------
//
//  This routine removes duplicate kanji form the list.  Particualry 
//  ru ending verbs result in duplicate entries in the list.  NOTE!
//  the callin sequence is key here, in particular, the routine must
//  be called after the kana is added to the end of the list.  This 
//  makes the list temination clean and allows some big optimizations,
//  at the expense of moving more memory during the compressions.
//
void JWP_conv::filter () {
  int base;     // Base for comparison, this moves through the list.
  int comp;     // Comparison, this is the list element being compared (base+1..end of list).
  int i,j;
  base = 0;
  while (true) {
    if (base == (comp = next(base))) return;            // Next does not move => the kana (done)!.
    while (true) {
      if (comp == (i = next(comp))) break;              // Next does not move => the kana (no match).
      i = len(comp);
      for (j = 0; j < i; j++) {                         // Compair loop.
        if (list[base+j] != list[comp+j]) break;        
      }
//
//  Double test, if j==i then character strings match to the end of the comp element.  But we 
//  have many compunds that are kanji+kana compared with kanji, so we need to make sure that 
//  that the base string is also at the end.  The test is done using next, so we do not have
//  to worry abount how the kanji list is actually stored.
//
      if ((j == i) && (base+j+1 == next(base))) {       // Is match so delete.
        i = next(comp);
        memmove (list+comp,list+i,(list_len-i+1)*sizeof(KANJI));
        list_len -= (i-comp);
        continue;                                       // Allows for multable matches in the list.
      }
      comp = next(comp);
    }
    base = next(base);
  }
  return;
}

//--------------------------------
//
//  Attempt to find a user's choice for kana->kanji conversion.  The
//  choice is based on the sel_key which was intialized when the 
//  conversion was begun.
//
//      RETURN -- Pointer to a KANJI_sel structure, or NULL if either,
//                the conversion is not in the list, or the key has 
//                been invalided.  Keys are invalidated when they are
//                longer than SIZE_SELKEY.
//
KANJI_sel *JWP_conv::find_choice () {
  int i,j;
  if (!sel_key[0]) return (NULL);
  for (i = 0; i < jwp_config.cfg.convert_size; i++) {
    for (j = 0; (j < SIZE_SELKEY) && (sel_key[j] == user_sel[i].key[j]); j++);
    if (j == SIZE_SELKEY) return (user_sel+i);
  }
  return (NULL);
}

//--------------------------------
//
//  Internal comparison routine used to compare a key against a key 
//  within the index file.
//
//      key    -- Key value to be compared.
//      id     -- Index into the index file.
//
//      RETURN -- >0 -- Key is greater than key associated with id.
//                =0 -- Keys are equal.
//                <0 -- Key is less than key associated with id.
//
int JWP_conv::index_compare ( const char *key,int id) {
  int i;
  for (i = 0; i < INDEXLEVEL; i++) {
    if (key[i] != index[id].key[i]) return (key[i]-index[id].key[i]);
    if (!key[i]) return (0);
  }
  return (0);
}

//--------------------------------
//
//  This routine intializes the kana->kanji conversion system.
//
int JWP_conv::initialize (WNDCLASS *wclass) {
  HANDLE file;
  long   isize;
  int    err;
  int    style;
  unsigned int done;
//
//  Make sure that the kanji list is actually allocated (i.e. the 
//  constructor did not fail).
//
  if (!list) return (true);
//
//  Read main kana->kanji dictionary.
//
#if  (CONVERT_ACCESS == CONVERT_ACCESS_MEMORY)
  err = false;
  if (INVALID_HANDLE_VALUE == (file = jwp_config.open(NAME_CONVT,OPEN_READ,false))) return (true);
  isize = GetFileSize (file,NULL);
  if (!(dict = (unsigned char *) malloc(isize)) || !ReadFile(file,dict,isize,&done,NULL)) err = true;
  CloseHandle (file);
  if (err) return (true);
#else
  if (INVALID_HANDLE_VALUE == (dict = jwp_config.open(NAME_CONVT,OPEN_READ,false))) return (true);
#endif
//
//  Read index file for main kana->kanji dictionary.
//
  err = false;
  if (INVALID_HANDLE_VALUE == (file = jwp_config.open(NAME_INDEX,OPEN_READ,false))) return (true);
  isize = GetFileSize (file,NULL);
  SetFilePointer (file,0,NULL,FILE_BEGIN);
  size = (short) (isize/sizeof(KANJI_index));
  if (!(index = (KANJI_index *) malloc (isize)) || !ReadFile(file,index,isize,&done,NULL)) err = true;
  CloseHandle (file);
  if (err) return (true);
//
//  Read user conversion cache.
//
  err = false;
  if (INVALID_HANDLE_VALUE == (file = jwp_config.open(NAME_USERSEL,OPEN_READ,true))) {
    isize = 0;
  }
  else {
    isize = GetFileSize (file,NULL);
    SetFilePointer (file,0,NULL,FILE_BEGIN);
    if ((unsigned long) isize > jwp_config.cfg.convert_size*sizeof(KANJI_sel)) isize = jwp_config.cfg.convert_size*sizeof(KANJI_sel);
  }
  if (!(user_sel = (KANJI_sel *) calloc (jwp_config.cfg.convert_size,sizeof(KANJI_sel))) || (isize && !ReadFile(file,user_sel,isize,&done,NULL))) err = true;
  CloseHandle (file);
  if (err) return (true);
  usersel_changed = false;
//
//  Read user dictionary.
//  
  user = (char *)load_image(jwp_config.name(NAME_USERCONV,OPEN_READ,true));
//
//  Generate window.
//
  if (wclass) {
    wclass->style         = CS_HREDRAW | CS_VREDRAW;
    wclass->lpfnWndProc   = JWP_conv_proc;
    wclass->hbrBackground = (HBRUSH) (COLOR_BTNFACE+1);
    wclass->lpszClassName = WINCLASS_CONVERTBAR;
    if (!RegisterClass(wclass)) return (true);
  }
  if (jwp_config.cfg.nokanjibar) {                              // User wants no kanji bar.
    height = 0;
    window = NULL;
  }
  else { 
    style = WS_CHILD | WS_VISIBLE | WS_BORDER;
    if (jwp_config.cfg.kscroll) style |= WS_HSCROLL;
    if (!(window = CreateWindow(WINCLASS_CONVERTBAR,NULL,style,0,0,0,0,main_window,(HMENU) 3,instance,NULL))) return (true);
    ShowWindow (window,SW_SHOW);
  }
  return (false);
}

//--------------------------------
//
//  This routine reallocates the size of the user selection buffer.
//  This routine is intended to be called by routines that manipulate
//  the settings.
//
//      size -- New size (in number of conversions).
//
void JWP_conv::realloc (short size) {
  KANJI_sel *new_user;
  int    i;
  if (!(new_user = (KANJI_sel *) calloc(size,sizeof(KANJI_sel)))) return;
  i = min(size,jwp_config.cfg.convert_size);
  memcpy (new_user,user_sel,i*sizeof(KANJI_sel));
  free   (user_sel);
  user_sel = new_user;
}

//--------------------------------
//
//  This is the main dictionary search routine.  It is used to 
//  search for entries in the user and the system conversion 
//  dictionaries.  Normally this is only called from JWP_conv::convert().
//  Typically it is called twice.  Onec to do a fixed end conversion, 
//  and once to do a variable end conversion, to pick up the 
//  conversion of verbs.
//
//      key     -- Key calculated for the kana string (see top of file).
//      endkana -- For exact match kanji, simply call with this parameter
//                 set to 0.  If this parameter is set to endkana, then 
//                 the rouitne will attempt to match variations of the 
//                 variable kanji compounds to the ending.  Generally, 
//                 this is used to match verb endings (nomu, momimasu, 
//                 etc.).
//
void JWP_conv::search ( const char *key,int endkana) {
  int i;
  IO_cache cache;
#if   (CONVERT_ACCESS == CONVERT_ACCESS_MEMORY)
  i = binary_search(key);           // Find key in index?
  if (i >= 0) {
    cache.input_memory (dict+index[i].offset);
    search_dict (key,endkana,&cache,true);
  }
#else
 char buffer[SIZE_BUFFER];         // Size of buffer used to read the WNN kana->
                                    // kanji dictionary.  This must read multable
                                    // lines.  The longest lines are above 256 unsigned chars.
  i = binary_search(key);           // Find key in index?

  if (i >= 0) {
    SetFilePointer (dict,index[i].offset,NULL,FILE_BEGIN);
    cache.input_file (buffer,SIZE_BUFFER,dict);
    search_dict (key,endkana,&cache,true);
  }
#endif
  if (user) {
    cache.input_memory (user);
    search_dict (key,endkana,&cache,false);
  }
  return;
}

//--------------------------------
//
//  This is the main dictionary search routine.  It is used to 
//  search for entries in a specific conversion dictionary (user or
//  WNN).  Normally this is only called from JWP_conv::search().
//  Typically it is called twice.  Onec to do a fixed end conversion, 
//  and once to do a variable end conversion, to pick up the 
//  conversion of verbs.
//
//      key     -- Key calculated for the kana string (see top of file).
//      endkana -- For exact match kanji, simply call with this parameter
//                 set to 0.  If this parameter is set to endkana, then 
//                 the rouitne will attempt to match variations of the 
//                 variable kanji compounds to the ending.  Generally, 
//                 this is used to match verb endings (nomu, momimasu, 
//                 etc.).
//      cache   -- IO_cache object that describes where we are to get
//                 the kana->kanji data from.  This can be a file or
//                 a memory cache.
//      sorted  -- If set to true, the dictionary being searched is 
//                 sorted, which means we can abort the search once 
//                 the key tests indicate we are beyond a match.  If 
//                 the dicitionary is not sorted, we must scan the 
//                 entire dictionary one entry at a time.
//
void JWP_conv::search_dict ( const char *key,int endkana,IO_cache *cache,int sorted) {
 char *kana;               // Points to kana string from ditionary (in key form).
  char  dict_ending;        // Pointer to ending code from dictonary.
 char *convert;            // Convert string from dictionary (kanji/kanji/...)
  char ending = '*';        // Type of ending allowed for this conversion.
  char *ascii;              // Points to ascii representaiton for endkana.
 char *ptr;
  int   i,j,diff;

  if (endkana) {                                // In endkana make ending
    ascii = kana_to_ascii(endkana);
    if (!ascii) return;
    if (*ascii == '+') ascii++;
    ending = *ascii;
  }
//
//  Dictionary search, we use get_line to advance through the cache.
//
  for (ptr = cache->get_line(); ptr && *ptr; ptr = cache->get_line()) {
    kana = ptr;                                 // Decode dictonary fields.
    while (*ptr && ( (unsigned char)*ptr > 0x7f)) ptr++;        // Find first non-key charcter
    dict_ending = *ptr++;
    for (convert = ptr; *ptr != '\n'; ptr++);   // Read pointer list.
    ptr++;
    diff = cmp_key(kana,key,endkana);          // Compare keys.
    if (diff > 0) {
      if (test_nkey(kana,key)) is_more = true;  // Test to see if kana can possible be added to string.
      if (sorted) break;                        // Past key in sorted dictionary so done.
      continue;                                 // Unsorted dictionary may still have entries.
    }
// ###
//  To support the user converisons, we expand all conversions.  This
//  can result in conversions beging entered in the list more than once.
//  This will result in extra duplicates in the list, but we will 
//  remove them in filter().
//
//  if (ending != dict_ending) continue;        // Edings don't match so skip this one.
    if (!test_endings(dict_ending,ending,endkana)) continue;
    if (!diff) {                                // have match.
      if (list_len) put_kanji ('/');            // Merge with list.
      for (i = 0; (convert[i] != '\n'); i++) {
        /* WORD? */
        if ( (unsigned char)convert[i] & 0x0080) {
          j = ( (unsigned char)convert[i++] << 8);
          put_kanji (j | (unsigned char)convert[i]);
        } 
        else {
          if (endkana && (convert[i] == '/')) put_kanji (endkana);
          put_kanji (convert[i]);
        }
      }
      if (endkana) put_kanji (endkana);
// ###
//  Removed this.  I do not think it is necessary, so the search will
//  go on.
//
//    if (sorted && (ending != '*')) break;     // Only one match for each ending?
    }
  }
  return;
}

//--------------------------------
//
//  Selects a kanji replacement string, and implements the replacement.
//  
//      s -- Index of replacement.
//
void JWP_conv::select (int s) {
  int        i;
  KANJI_sel *choice;
//
//  Scroll kanji bar to make current selection visable.
//
  KANJI_list::select (s);
//
//  Put selection back into file.
//
  file->put_kanji (list+selected,len(selected));
//
//  Store user choice in user conversion dictionary.
//
  if (!sel_key[0] || (selected == last())) return;  // Not chached: too many kana or user chose kana.
  if ((choice = find_choice())) {                   // Dicitonary has an entry for this kana string.
    if (choice->select != selected) {               // Choice is same or different.
      choice->select  = selected;
      usersel_changed = true;
    }
  }
  else if (selected) {                              // Generate new entry if selected is not 0.
// ### may want to change the way entries are placed in table.
    usersel_changed = true;
    memmove (user_sel,user_sel+1,(jwp_config.cfg.convert_size-1)*sizeof(KANJI_sel));
    for (i = 0; i < SIZE_SELKEY; i++) user_sel[jwp_config.cfg.convert_size-1].key[i] = sel_key[i];
    user_sel[jwp_config.cfg.convert_size-1].select = selected;
  }
  return;
}

//
//  End Class JWP_conv.
//
//===================================================================

//===================================================================
//
//  Begin Class JWP_file.
//
//  Parts of the JWP_file class related directly to the kana->kanji
//  converter.
//

//--------------------------------
//
//  Main entry point from other routines is this.  This routine is 
//  called when the user selects one of the kana->kanji conversion 
//  routines (menu, F2, F3, etc.).  If a conversion is in progress,
//  the routine changes the selected kanji.  If the conversion is 
//  not in progress it inititiates a conversion.
//
//      code -- If the conversion alread in progress, this flag
//              tells the routine which direction to change the 
//              selection.  If a conversion is not in progress, 
//              can be an attempt to generate a conversion 
//              automatically.
//
//              CONVERT_RIGHT   -- Change conversion to right.
//              CONVERT_LEFT    -- Change conversion to left.
//              CONVERT_ATTEMPT -- Attempt conversion (used as a 
//                                 responce to an auto-conversion 
//                                 attempt).
//
void JWP_file::convert (int code) {
  int i,j;
  KANJI *kptr;
//
//  Set file setting so we can know where to put the kanji back.
//
  if (jwp_conv.file != this) {
    if (code != CONVERT_ATTEMPT) kana_convert.force ();     // Force characters out into hiragana coversion.
                                                            //   This is required to alow A F2 combinations
                                                            //   to work correctly.  Otherwise the following
                                                            //   clear will force the A out into katakana.
                                                            //   We do not want to force if the code is 
                                                            //   CONVERT_ATTEMPT the conversion is just an 
                                                            //   Attempt, and we do not want to do the conversion,
                                                            //   because we don't know what the user wants.
    jwp_conv.clear();
  }
  jwp_conv.file = this;
//
//  If a conversion is in process, simply change the selected kanji.
//
  if (sel.type == SELECT_CONVERT) {
    jwp_conv.do_select (code);
    return;
  }
//
//  If not conversion in progress, then we need to start a new 
//  conversion, or attempt a new conversion.
//
  if (code != CONVERT_ATTEMPT) {                            // Dump kana conversion buffer.
    kana_convert.force ();                                  // Force characters out into hiragana coversion.
  }
  if (!sel.type || (sel.pos1.para != sel.pos2.para)) { MessageBeep (MB_ICONASTERISK); return; }
  all_abs ();                                               // Extract kana string.
  j = false;
  for (i = sel.pos1.pos; (i < sel.pos2.pos) && (i < sel.pos1.para->length); i++) if (!ISHIRAGANA(sel.pos1.para->text[i])) j = true;
  i = sel.pos2.pos-sel.pos1.pos;
  kptr = sel.pos1.para->text+sel.pos1.pos;
  all_rel ();
  if (j && (code != CONVERT_ATTEMPT)) { MessageBeep (MB_ICONASTERISK); return; }
//
//  If this is an attempt, first do an attempt.  If this cannot be 
//  matched, backup up one kana and do a conversion.
//
//  An CONVERT_ATTEMPT, is only made from auto kana->kanji conversion.
//  During auto-conversion, an attempt is made as every kana is 
//  added to the conversion.  The attempt routine will return a false
//  if the current conversion is not valid.  In this case, we keep 
//  removing characters until we get a valid kanki compound.  
//
  if (code == CONVERT_ATTEMPT) {
    if (!jwp_conv.attempt(kptr,i)) {
      do {
        sel.pos2.advance (-1);
        i--;
        if (!i) { jwp_conv.clear(); return; }
      } while (!jwp_conv.convert(kptr,i));
      jwp_conv.do_convert (kptr,i);         
    }
    return;
  }
//
//  Forced conversion (press F2, F3).
//
  jwp_conv.do_convert (kptr,i);
  return;
}

//--------------------------------
//
//  Routine inserts a kanji substitution back into a file, and 
//  adjust the marks.
//
//      kanji  -- Kanji string to be inserted.
//      length -- Length of the string.
//
#define MOVETO_POS1 -1

void JWP_file::put_kanji (KANJI *kanji,int length) {
  int move;
  all_abs ();
  if (cursor.pos == sel.pos1.pos) move = MOVETO_POS1; else move = cursor.pos-sel.pos2.pos;
  if (sel.type != SELECT_CONVERT) {         // This forces a undo reset when starting a kanji
    undo_clear (UNDO_NONE);                 //   conversion.  ### Have to think about this.
    undo_para  (UNDO_TYPE);
  }
  selection_delete ();
  sel.pos1.para->ins_string (this,sel.pos1.line,sel.pos1.pos,kanji,length);
  sel.pos1.abs ();
  sel.pos2 = sel.pos1;
  sel.pos2.pos += length;
  sel.type = SELECT_CONVERT;
  cursor = sel.pos1;
  if (move != MOVETO_POS1) cursor.pos = move+sel.pos2.pos;
  edit_menu ();
  all_rel ();
  adjust ();
  return;  
}

//
//  End Class JWP_file.
//
//===================================================================

// ### may want to change the way the kanji list buffer is generated and operates.

//### Would like to improve the kana->kanji conversion.
//### If the convert is expanded to a two deep character endings,
//### we will be able to handle te form and ta form endings better.
